!function(e){var t={};function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(r,i,function(t){return e[t]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=17)}([function(e,t){e.exports="// Copyright 2019 Yuchen Wang\n\nvarying vec2 coord;\nvarying vec3 position;\n\nvoid main() {\n  coord = gl_Vertex.xy * 0.5 + 0.5;\n  position = gl_Vertex.xyz;\n  gl_Position = vec4(gl_Vertex.xyz, 1.0);\n}\n"},function(e,t){e.exports="// Copyright 2019 Yuchen Wang\n\nuniform vec3 sphereCenter;\nuniform float sphereRadius;\n\nvarying vec3 position;\nvarying vec3 actualPosition;\n\nvoid main() {\n  position = sphereCenter + gl_Vertex.xyz * sphereRadius + (1.0 - 0.1 * gl_Vertex.z) * sphereRadius;\n  actualPosition = sphereCenter + gl_Vertex.xyz * sphereRadius;\n  gl_Position = gl_ModelViewProjectionMatrix * vec4(position, 1.0);\n}\n"},function(e,t){e.exports="// Copyright 2019 Yuchen Wang\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\nconst float poolHeight = 1.0;\nuniform vec3 light;\nuniform vec3 sphereCenter;\nuniform float sphereRadius;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nuniform vec3 eye;\nvarying vec3 position;\nvarying vec3 actualPosition;\nuniform samplerCube sky;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor, int t);\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nfloat intersectSphere(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {\n  vec3 toSphere = origin - sphereCenter;\n  float a = dot(ray, ray);\n  float b = 2.0 * dot(toSphere, ray);\n  float c = dot(toSphere, toSphere) - sphereRadius * sphereRadius;\n  float discriminant = b*b - 4.0*a*c;\n  if (discriminant > 0.0) {\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    if (t1 > 0.0) return t1;\n    else if (t2 > 0.0) return t2;\n  }\n  return 1.0e6;\n}\n\nvec3 getBubbleColor(vec3 point, int t) {\n  vec3 color = vec3(0.3);\n\n  vec3 incomingRay = normalize(position - eye);\n  vec3 normal = normalize(actualPosition - sphereCenter);\n\n  vec3 reflectedRay = reflect(incomingRay, normal);\n  vec3 reflectedColor = getSurfaceRayColor(position + 1e-4 * normal, reflectedRay, underwaterColor, t + 1);\n\n  vec3 refractedColor = vec3(0.0, 0.0, 0.0);\n  vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n  float tt = intersectSphere(position, refractedRay, sphereCenter, sphereRadius);\n  if (tt < 1e+6) {\n    vec3 nextHit = position + tt * refractedRay;\n    vec3 nextNormal = normalize(sphereCenter - nextHit);\n    vec3 nextRefractedRay = refract(refractedRay, nextNormal, IOR_AIR / IOR_WATER);\n    refractedColor = dot(-nextNormal, nextRefractedRay) * getSurfaceRayColor(nextHit - 1e-4 * nextNormal, nextRefractedRay, underwaterColor, t + 1);\n  }\n\n  float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n  color += fresnel * dot(normal, reflectedColor) * reflectedColor;\n  color += (1.0 - fresnel) * dot(-normal, refractedRay) * refractedColor;\n\n  return color;\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n  \n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n  \n  scale /= length(point); /* pool ambient occlusion */\n  scale *= 1.0 - 0.9 / pow(length(point - sphereCenter) / sphereRadius, 4.0); /* sphere ambient occlusion */\n  \n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n    \n    scale += diffuse * 0.5;\n  }\n  \n  return wallColor * scale;\n}\n\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor, int t) {\n  vec3 color;\n  float q = intersectSphere(origin, ray, sphereCenter, sphereRadius);\n  if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 2.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += vec3(pow(max(0.0, dot(light, ray)), 5000.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n  if (ray.y < 0.0) color *= waterColor;\n  return color;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, position.xz * 0.5 + 0.5);\n  if (position.y < info.r) {\n    gl_FragColor = vec4(getBubbleColor(actualPosition, 0), 1.0);\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  } else {\n    vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n    vec3 incomingRay = normalize(position - eye);\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n    \n    vec3 reflectedColor = getSurfaceRayColor(position, reflectedRay, abovewaterColor, 0);\n    vec3 refractedColor = getSurfaceRayColor(position, refractedRay, abovewaterColor, 0);\n    \n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}\n"},function(e,t){e.exports="// Copyright 2019 Yuchen Wang\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\nconst float poolHeight = 1.0;\nuniform vec3 light;\nuniform sampler2D water;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n    vec3 tMin = (cubeMin - origin) / ray;\n    vec3 tMax = (cubeMax - origin) / ray;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n  }\n\n/* project the ray onto the plane */\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  origin += ray * tcube.y;\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n  return origin + refractedLight * tplane;\n}\n\nvoid main() {\n  vec4 info = texture2D(water, gl_Vertex.xy * 0.5 + 0.5);\n  info.ba *= 0.5;\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  \n  /* project the vertices along the refracted vertex ray */\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\n  oldPos = project(gl_Vertex.xzy, refractedLight, refractedLight);\n  newPos = project(gl_Vertex.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n  \n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\n}\n"},function(e,t){e.exports="// Copyright 2019 Yuchen Wang\n\n#extension GL_OES_standard_derivatives : enable\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\nconst float poolHeight = 1.0;\nuniform bool hasDerivatives;\nuniform vec3 light;\nuniform vec3 sphereCenter;\nuniform float sphereRadius;\n\nvarying vec3 oldPos;\nvarying vec3 newPos;\nvarying vec3 ray;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvoid main() {\n  if (hasDerivatives) {\n    /* if the triangle gets smaller, it gets brighter, and vice versa */\n    float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\n    float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\n    gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n  } else {\n    gl_FragColor = vec4(0.2, 0.2, 0.0, 0.0);\n  }\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  \n  /* compute a blob shadow and make sure we only draw a shadow if the player is blocking the light */\n  vec3 dir = (sphereCenter - newPos) / sphereRadius;\n  vec3 area = cross(dir, refractedLight);\n  float shadow = dot(area, area);\n  float dist = dot(dir, -refractedLight);\n  shadow = 1.0 + (shadow - 1.0) / (0.05 + dist * 0.025);\n  shadow = clamp(1.0 / (1.0 + exp(-shadow)), 0.0, 1.0);\n  shadow = mix(1.0, shadow, clamp(dist * 2.0, 0.0, 1.0));\n  gl_FragColor.g = shadow;\n  \n  /* shadow for the rim of the pool */\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\n}\n"},function(e,t){e.exports="// Copyright 2019 Yuchen Wang\n\nconst float poolHeight = 1.0;\n\nvarying vec3 position;\n\nvoid main() {\n  position = gl_Vertex.xyz;\n  position.y = ((1.0 - position.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n  gl_Position = gl_ModelViewProjectionMatrix * vec4(position, 1.0);\n}\n"},function(e,t){e.exports="// Copyright 2019 Yuchen Wang\n\nvarying vec3 position;\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\nuniform vec3 sphereCenter;\nuniform float sphereRadius;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n  \n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n  \n  scale /= length(point); /* pool ambient occlusion */\n  scale *= 1.0 - 0.9 / pow(length(point - sphereCenter) / sphereRadius, 4.0); /* sphere ambient occlusion */\n  \n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n    \n    scale += diffuse * 0.5;\n  }\n  \n  return wallColor * scale;\n}\n\nvoid main() {\n  gl_FragColor = vec4(getWallColor(position), 1.0);\n  vec4 info = texture2D(water, position.xz * 0.5 + 0.5);\n  if (position.y < info.y) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}\n"},function(e,t){e.exports="// Copyright 2019 Yuchen Wang\n\nuniform vec3 sphereCenter;\nuniform float sphereRadius;\n\nvarying vec3 position;\n\nvoid main() {\n  position = sphereCenter + gl_Vertex.xyz * sphereRadius;\n  gl_Position = gl_ModelViewProjectionMatrix * vec4(position, 1.0);\n}\n"},function(e,t){e.exports="// Copyright 2019 Yuchen Wang\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\nconst float poolHeight = 1.0;\nuniform vec3 light;\nuniform vec3 sphereCenter;\nuniform float sphereRadius;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvarying vec3 position;\n\nvec3 getSphereColor(vec3 point) {\n  vec3 color = vec3(0.5);\n  \n  /* ambient occlusion with walls */\n  color *= 1.0 - 0.9 / pow((1.0 + sphereRadius - abs(point.x)) / sphereRadius, 3.0);\n  color *= 1.0 - 0.9 / pow((1.0 + sphereRadius - abs(point.z)) / sphereRadius, 3.0);\n  color *= 1.0 - 0.9 / pow((point.y + 1.0 + sphereRadius) / sphereRadius, 3.0);\n  \n  /* caustics */\n  vec3 sphereNormal = (point - sphereCenter) / sphereRadius;\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(-refractedLight, sphereNormal)) * 0.5;\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    diffuse *= caustic.r * 4.0;\n  }\n  color += diffuse;\n  \n  return color;\n}\n\nvoid main() {\n  gl_FragColor = vec4(getSphereColor(position), 1.0);\n  vec4 info = texture2D(water, position.xz * 0.5 + 0.5);\n  if (position.y < info.r) {\n    gl_FragColor.rgb *= underwaterColor * 1.2;\n  }\n}\n"},function(e,t){e.exports="// Copyright 2019 Yuchen Wang\n\nuniform sampler2D water;\nvarying vec3 position;\n\nvoid main() {\n  vec4 info = texture2D(water, gl_Vertex.xy * 0.5 + 0.5);\n  position = gl_Vertex.xzy;\n  position.y += info.r;\n  gl_Position = gl_ModelViewProjectionMatrix * vec4(position, 1.0);\n}\n"},function(e,t){e.exports='// Copyright 2019 Yuchen Wang\n\nconst float IOR_AIR = 1.0;\nconst float IOR_WATER = 1.333;\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\nconst float poolHeight = 1.0;\nuniform vec3 light;\nuniform vec3 sphereCenter;\nuniform float sphereRadius;\nuniform sampler2D tiles;\nuniform sampler2D causticTex;\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\n  vec3 tMin = (cubeMin - origin) / ray;\n  vec3 tMax = (cubeMax - origin) / ray;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\nfloat intersectSphere(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {\n  vec3 toSphere = origin - sphereCenter;\n  float a = dot(ray, ray);\n  float b = 2.0 * dot(toSphere, ray);\n  float c = dot(toSphere, toSphere) - sphereRadius * sphereRadius;\n  float discriminant = b*b - 4.0*a*c;\n  if (discriminant > 0.0) {\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    if (t1 > 0.0) return t1;\n    else if (t2 > 0.0) return t2;\n  }\n  return 1.0e6;\n}\n\nvec3 getSphereColor(vec3 point) {\n  vec3 color = vec3(0.5);\n  \n  /* ambient occlusion with walls */\n  color *= 1.0 - 0.9 / pow((1.0 + sphereRadius - abs(point.x)) / sphereRadius, 3.0);\n  color *= 1.0 - 0.9 / pow((1.0 + sphereRadius - abs(point.z)) / sphereRadius, 3.0);\n  color *= 1.0 - 0.9 / pow((point.y + 1.0 + sphereRadius) / sphereRadius, 3.0);\n  \n  /* caustics */\n  vec3 sphereNormal = (point - sphereCenter) / sphereRadius;\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(-refractedLight, sphereNormal)) * 0.5;\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    diffuse *= caustic.r * 4.0;\n  }\n  color += diffuse;\n  \n  return color;\n}\n\nvec3 getWallColor(vec3 point) {\n  float scale = 0.5;\n  \n  vec3 wallColor;\n  vec3 normal;\n  if (abs(point.x) > 0.999) {\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(-point.x, 0.0, 0.0);\n  } else if (abs(point.z) > 0.999) {\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\n    normal = vec3(0.0, 0.0, -point.z);\n  } else {\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\n    normal = vec3(0.0, 1.0, 0.0);\n  }\n  \n  scale /= length(point); /* pool ambient occlusion */\n  scale *= 1.0 - 0.9 / pow(length(point - sphereCenter) / sphereRadius, 4.0); /* sphere ambient occlusion */\n  \n  /* caustics */\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n  float diffuse = max(0.0, dot(refractedLight, normal));\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\n  if (point.y < info.r) {\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\n  } else {\n    /* shadow for the rim of the pool */\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n    \n    scale += diffuse * 0.5;\n  }\n  \n  return wallColor * scale;\n}\n\nuniform vec3 eye;\nvarying vec3 position;\nuniform samplerCube sky;\nuniform int isUnderWater;\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\n  vec3 color;\n  float q = intersectSphere(origin, ray, sphereCenter, sphereRadius);\n  if (q < 1.0e6) {\n    color = getSphereColor(origin + ray * q);\n  } else if (ray.y < 0.0) {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    color = getWallColor(origin + ray * t.y);\n  } else {\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\n    vec3 hit = origin + ray * t.y;\n    if (hit.y < 2.0 / 12.0) {\n      color = getWallColor(hit);\n    } else {\n      color = textureCube(sky, ray).rgb;\n      color += vec3(pow(max(0.0, dot(light, ray)), 5000.0)) * vec3(10.0, 8.0, 6.0);\n    }\n  }\n  if (ray.y < 0.0) color *= waterColor;\n  return color;\n}\n\nvoid main() {\n  vec2 coord = position.xz * 0.5 + 0.5;\n  vec4 info = texture2D(water, coord);\n  \n  /* make water look more "peaked" */\n  for (int i = 0; i < 5; i++) {\n    coord += info.ba * 0.005;\n    info = texture2D(water, coord);\n  }\n  \n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n  vec3 incomingRay = normalize(position - eye);\n  \n  if (isUnderWater > 0) {\n    normal = -normal;\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n    \n    vec3 reflectedColor = getSurfaceRayColor(position, reflectedRay, underwaterColor);\n    vec3 refractedColor = getSurfaceRayColor(position, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n    \n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\n  } else {\n    vec3 reflectedRay = reflect(incomingRay, normal);\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n    \n    vec3 reflectedColor = getSurfaceRayColor(position, reflectedRay, abovewaterColor);\n    vec3 refractedColor = getSurfaceRayColor(position, refractedRay, abovewaterColor);\n    \n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\n  }\n}\n'},function(e,t){e.exports="// Copyright 2019 Yuchen Wang\n\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\n\nvoid main() {\n  vec4 info = texture2D(texture, coord);\n\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n\n  gl_FragColor = info;\n}\n"},function(e,t){e.exports="// Copyright 2019 Yuchen Wang\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  vec4 info = texture2D(texture, coord);\n\n  // update the normal\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + 0.5 * delta.x, coord.y)).r - info.r, 0.0);\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + 0.5 * delta.y)).r - info.r, 0.5 * delta.y);\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\n}\n"},function(e,t){e.exports="// Copyright 2019 Yuchen Wang\n\nuniform sampler2D texture;\nuniform vec3 oldCenter;\nuniform vec3 newCenter;\nuniform float radius;\nvarying vec2 coord;\nvarying vec3 position;\n\nfloat volumeInSphere(vec3 center) {\n  vec3 toCenter = vec3(coord.x * 2.0 - 1.0, 0.0, coord.y * 2.0 - 1.0) - center;\n  float t = length(toCenter) / radius;\n  float dy = exp(-pow(t * 1.5, 6.0));\n  float ymin = min(0.0, center.y - dy);\n  float ymax = min(max(0.0, center.y + dy), ymin + 2.0 * dy);\n  return (ymax - ymin) * 0.1;\n}\n\nvoid main() {\n  /* get vertex info */\n  vec4 info = texture2D(texture, coord);\n\n  /* add the old volume */\n  info.r += volumeInSphere(oldCenter);\n  \n  /* subtract the new volume */\n  float volume = volumeInSphere(newCenter);\n\n  if (volume > 0.0) {\n    float height = info.r;\n    if (position.y <= height) {\n      info.r -= volume;\n    } else {\n      info.r += 0.01 * radius;\n    }\n  }\n\n  gl_FragColor = info;\n}\n"},function(e,t){e.exports="// Copyright 2019 Yuchen Wang\n\nuniform sampler2D texture;\nuniform vec3 oldCenter;\nuniform vec3 newCenter;\nuniform float radius;\nvarying vec2 coord;\n\nfloat volumeInSphere(vec3 center) {\n  vec3 toCenter = vec3(coord.x * 2.0 - 1.0, 0.0, coord.y * 2.0 - 1.0) - center;\n  float t = length(toCenter) / radius;\n  float dy = exp(-pow(t * 1.5, 6.0));\n  float ymin = min(0.0, center.y - dy);\n  float ymax = min(max(0.0, center.y + dy), ymin + 2.0 * dy);\n  return (ymax - ymin) * 0.1;\n}\n\nvoid main() {\n  /* get vertex info */\n  vec4 info = texture2D(texture, coord);\n\n  /* add the old volume */\n  info.r += volumeInSphere(oldCenter);\n  \n  /* subtract the new volume */\n  info.r -= volumeInSphere(newCenter);\n\n  gl_FragColor = info;\n}\n"},function(e,t){e.exports="// Copyright 2019 Yuchen Wang\n\nuniform sampler2D texture;\nuniform vec3 oldCenter;\nuniform vec3 newCenter;\nuniform float radius;\nvarying vec2 coord;\nvarying vec3 position;\n\nfloat volumeInSphere(vec3 center) {\n  vec3 toCenter = vec3(coord.x * 2.0 - 1.0, 0.0, coord.y * 2.0 - 1.0) - center;\n  float t = length(toCenter) / radius;\n  float dy = exp(-pow(t * 1.5, 6.0));\n  float ymin = min(0.0, center.y - dy);\n  float ymax = min(max(0.0, center.y + dy), ymin + 2.0 * dy);\n  return (ymax - ymin) * 0.1;\n}\n\n// Fluid reconstraction kernel function.\nfloat W(float h, float d) {\n  if (d > h)\n    return 0.8 * h;\n  else {\n    return (315.0 * pow(h-d, 3.0)) / (64.0 * 3.1415926 * pow(h, 4.0));\n  }\n}\n\nvoid main() {\n  /* get vertex info */\n  vec4 info = texture2D(texture, coord);\n\n  float oldVolume = volumeInSphere(oldCenter);\n  info.r += oldVolume;\n\n  float newVolume = volumeInSphere(newCenter);\n  if (newVolume > 0.0) { \n    // Fluid surface reconstruction\n    float h = 2.0 * radius * (2.0 + info.r - newCenter.y);\n    float dis = pow(length(newCenter - position), 2.0);\n    info.r += 0.005 * (W(h, dis) - W(h/2.0, dis));\n   }\n\n  gl_FragColor = info;\n}\n"},function(e,t){e.exports="// Copyright 2019 Yuchen Wang\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\n\nvoid main() {\n  vec4 info = texture2D(texture, coord);\n\n  // Calculate neibour height\n  vec2 dx = vec2(0.5 * delta.x, 0.0);\n  vec2 dy = vec2(0.0, 0.5 * delta.y);\n  float average = (\n      texture2D(texture, coord - 0.5 * dx).r +\n      texture2D(texture, coord - 0.5 * dy).r +\n      texture2D(texture, coord + 0.5 * dx).r + \n      texture2D(texture, coord + 0.5 * dy).r) * 0.25;\n\n  info.g += (average - info.r) * 2.0;\n  info.g *= 0.995;\n  info.r += info.g;\n  gl_FragColor = info;\n}\n"},function(e,t,n){e.exports=n(18)},function(e,t,n){"use strict";n.r(t);var r=function(){var e,t={create:function(t){t=t||{};var n,c,u=document.createElement("canvas");u.width=800,u.height=600,"alpha"in t||(t.alpha=!1);try{e=u.getContext("webgl",t)}catch(e){}try{e=e||u.getContext("experimental-webgl",t)}catch(e){}if(!e)throw new Error("WebGL not supported");return e.HALF_FLOAT_OES=36193,function(){e.MODELVIEW=1|o,e.PROJECTION=2|o;var t=new s,n=new s;e.modelviewMatrix=new s,e.projectionMatrix=new s;var r,i,c=[],u=[];e.matrixMode=function(t){switch(t){case e.MODELVIEW:r="modelviewMatrix",i=c;break;case e.PROJECTION:r="projectionMatrix",i=u;break;default:throw new Error("invalid matrix mode "+t)}},e.loadIdentity=function(){s.identity(e[r])},e.loadMatrix=function(t){for(var n=t.m,i=e[r].m,o=0;o<16;o++)i[o]=n[o]},e.multMatrix=function(t){e.loadMatrix(s.multiply(e[r],t,n))},e.perspective=function(n,r,i,o){e.multMatrix(s.perspective(n,r,i,o,t))},e.frustum=function(n,r,i,o,a,c){e.multMatrix(s.frustum(n,r,i,o,a,c,t))},e.ortho=function(n,r,i,o,a,c){e.multMatrix(s.ortho(n,r,i,o,a,c,t))},e.scale=function(n,r,i){e.multMatrix(s.scale(n,r,i,t))},e.translate=function(n,r,i){e.multMatrix(s.translate(n,r,i,t))},e.rotate=function(n,r,i,o){e.multMatrix(s.rotate(n,r,i,o,t))},e.lookAt=function(n,r,i,o,a,c,u,l,h){e.multMatrix(s.lookAt(n,r,i,o,a,c,u,l,h,t))},e.pushMatrix=function(){i.push(Array.prototype.slice.call(e[r].m))},e.popMatrix=function(){var t=i.pop();e[r].m=a?new Float32Array(t):t},e.project=function(t,n,r,i,o,a){i=i||e.modelviewMatrix,o=o||e.projectionMatrix,a=a||e.getParameter(e.VIEWPORT);var s=o.transformPoint(i.transformPoint(new E(t,n,r)));return new E(a[0]+a[2]*(.5*s.x+.5),a[1]+a[3]*(.5*s.y+.5),.5*s.z+.5)},e.unProject=function(r,i,o,a,c,u){a=a||e.modelviewMatrix,c=c||e.projectionMatrix;var l=new E((r-(u=u||e.getParameter(e.VIEWPORT))[0])/u[2]*2-1,(i-u[1])/u[3]*2-1,2*o-1);return s.inverse(s.multiply(c,a,t),n).transformPoint(l)},e.matrixMode(e.MODELVIEW)}(),n={mesh:new l({coords:!0,colors:!0,triangles:!1}),mode:-1,coord:[0,0,0,0],color:[1,1,1,1],pointSize:1,shader:new g("      uniform float pointSize;      varying vec4 color;      varying vec4 coord;      void main() {        color = gl_Color;        coord = gl_TexCoord;        gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;        gl_PointSize = pointSize;      }    ","      uniform sampler2D texture;      uniform float pointSize;      uniform bool useTexture;      varying vec4 color;      varying vec4 coord;      void main() {        gl_FragColor = color;        if (useTexture) gl_FragColor *= texture2D(texture, coord.xy);      }    ")},e.pointSize=function(e){n.shader.uniforms({pointSize:e})},e.begin=function(e){if(-1!=n.mode)throw new Error("mismatched gl.begin() and gl.end() calls");n.mode=e,n.mesh.colors=[],n.mesh.coords=[],n.mesh.vertices=[]},e.color=function(e,t,r,i){n.color=1==arguments.length?e.toArray().concat(1):[e,t,r,i||1]},e.texCoord=function(e,t){n.coord=1==arguments.length?e.toArray(2):[e,t]},e.vertex=function(e,t,r){n.mesh.colors.push(n.color),n.mesh.coords.push(n.coord),n.mesh.vertices.push(1==arguments.length?e.toArray():[e,t,r])},e.end=function(){if(-1==n.mode)throw new Error("mismatched gl.begin() and gl.end() calls");n.mesh.compile(),n.shader.uniforms({useTexture:!!e.getParameter(e.TEXTURE_BINDING_2D)}).draw(n.mesh,n.mode),n.mode=-1},function(){var t=e,n=0,o=0,a={},s=!1,c=Object.prototype.hasOwnProperty;function u(){for(var e in a)if(c.call(a,e)&&a[e])return!0;return!1}function l(t){var r={};for(var i in t)"function"==typeof t[i]?r[i]=function(e){return function(){e.apply(t,arguments)}}(t[i]):r[i]=t[i];r.original=t,r.x=r.pageX,r.y=r.pageY;for(var a=e.canvas;a;a=a.offsetParent)r.x-=a.offsetLeft,r.y-=a.offsetTop;return s?(r.deltaX=r.x-n,r.deltaY=r.y-o):(r.deltaX=0,r.deltaY=0,s=!0),n=r.x,o=r.y,r.dragging=u(),r.preventDefault=function(){r.original.preventDefault()},r.stopPropagation=function(){r.original.stopPropagation()},r}function h(n){e=t,n=l(n),e.onmousemove&&e.onmousemove(n),n.preventDefault()}function f(n){e=t,a[n.which]=!1,u()||(i(document,"mousemove",h),i(document,"mouseup",f),r(e.canvas,"mousemove",h),r(e.canvas,"mouseup",f)),n=l(n),e.onmouseup&&e.onmouseup(n),n.preventDefault()}function d(){s=!1}r(e.canvas,"mousedown",(function(n){e=t,u()||(r(document,"mousemove",h),r(document,"mouseup",f),i(e.canvas,"mousemove",h),i(e.canvas,"mouseup",f)),a[n.which]=!0,n=l(n),e.onmousedown&&e.onmousedown(n),n.preventDefault()})),r(e.canvas,"mousemove",h),r(e.canvas,"mouseup",f),r(e.canvas,"mouseover",d),r(e.canvas,"mouseout",d),r(document,"contextmenu",(function(){a={},s=!1}))}(),c=e,e.makeCurrent=function(){e=c},e.animate=function(){var t=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||function(e){setTimeout(e,1e3/60)},n=(new Date).getTime(),r=e;!function i(){e=r;var o=(new Date).getTime();e.onupdate&&e.onupdate((o-n)/1e3),e.ondraw&&e.ondraw(),t(i),n=o}()},e.fullscreen=function(t){var n=(t=t||{}).paddingTop||0,i=t.paddingLeft||0,o=t.paddingRight||0,a=t.paddingBottom||0;if(!document.body)throw new Error("document.body doesn't exist yet (call gl.fullscreen() from window.onload() or from inside the <body> tag)");function s(){e.canvas.width=window.innerWidth-i-o,e.canvas.height=window.innerHeight-n-a,e.viewport(0,0,e.canvas.width,e.canvas.height),!t.camera&&"camera"in t||(e.matrixMode(e.PROJECTION),e.loadIdentity(),e.perspective(t.fov||45,e.canvas.width/e.canvas.height,t.near||.1,t.far||1e3),e.matrixMode(e.MODELVIEW)),e.ondraw&&e.ondraw()}document.body.appendChild(e.canvas),document.body.style.overflow="hidden",e.canvas.style.position="absolute",e.canvas.style.left=i+"px",e.canvas.style.top=n+"px",r(window,"resize",s),s()},e},keys:{},Matrix:s,Indexer:c,Buffer:u,Mesh:l,HitTest:d,Raytracer:m,Shader:g,Texture:R,Vector:E};function n(e){return{8:"BACKSPACE",9:"TAB",13:"ENTER",16:"SHIFT",27:"ESCAPE",32:"SPACE",37:"LEFT",38:"UP",39:"RIGHT",40:"DOWN"}[e]||(e>=65&&e<=90?String.fromCharCode(e):null)}function r(e,t,n){e.addEventListener(t,n)}function i(e,t,n){e.removeEventListener(t,n)}r(document,"keydown",(function(e){if(!e.altKey&&!e.ctrlKey&&!e.metaKey){var r=n(e.keyCode);r&&(t.keys[r]=!0),t.keys[e.keyCode]=!0}})),r(document,"keyup",(function(e){if(!e.altKey&&!e.ctrlKey&&!e.metaKey){var r=n(e.keyCode);r&&(t.keys[r]=!1),t.keys[e.keyCode]=!1}}));var o=305397760,a="undefined"!=typeof Float32Array;function s(){var e=Array.prototype.concat.apply([],arguments);e.length||(e=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),this.m=a?new Float32Array(e):e}function c(){this.unique=[],this.indices=[],this.map={}}function u(e,t){this.buffer=null,this.target=e,this.type=t,this.data=[]}function l(e){e=e||{},this.vertexBuffers={},this.indexBuffers={},this.addVertexBuffer("vertices","gl_Vertex"),e.coords&&this.addVertexBuffer("coords","gl_TexCoord"),e.normals&&this.addVertexBuffer("normals","gl_Normal"),e.colors&&this.addVertexBuffer("colors","gl_Color"),"triangles"in e&&!e.triangles||this.addIndexBuffer("triangles"),e.lines&&this.addIndexBuffer("lines")}s.prototype={inverse:function(){return s.inverse(this,new s)},transpose:function(){return s.transpose(this,new s)},multiply:function(e){return s.multiply(this,e,new s)},transformPoint:function(e){var t=this.m;return new E(t[0]*e.x+t[1]*e.y+t[2]*e.z+t[3],t[4]*e.x+t[5]*e.y+t[6]*e.z+t[7],t[8]*e.x+t[9]*e.y+t[10]*e.z+t[11]).divide(t[12]*e.x+t[13]*e.y+t[14]*e.z+t[15])},transformVector:function(e){var t=this.m;return new E(t[0]*e.x+t[1]*e.y+t[2]*e.z,t[4]*e.x+t[5]*e.y+t[6]*e.z,t[8]*e.x+t[9]*e.y+t[10]*e.z)}},s.inverse=function(e,t){t=t||new s;var n=e.m,r=t.m;r[0]=n[5]*n[10]*n[15]-n[5]*n[14]*n[11]-n[6]*n[9]*n[15]+n[6]*n[13]*n[11]+n[7]*n[9]*n[14]-n[7]*n[13]*n[10],r[1]=-n[1]*n[10]*n[15]+n[1]*n[14]*n[11]+n[2]*n[9]*n[15]-n[2]*n[13]*n[11]-n[3]*n[9]*n[14]+n[3]*n[13]*n[10],r[2]=n[1]*n[6]*n[15]-n[1]*n[14]*n[7]-n[2]*n[5]*n[15]+n[2]*n[13]*n[7]+n[3]*n[5]*n[14]-n[3]*n[13]*n[6],r[3]=-n[1]*n[6]*n[11]+n[1]*n[10]*n[7]+n[2]*n[5]*n[11]-n[2]*n[9]*n[7]-n[3]*n[5]*n[10]+n[3]*n[9]*n[6],r[4]=-n[4]*n[10]*n[15]+n[4]*n[14]*n[11]+n[6]*n[8]*n[15]-n[6]*n[12]*n[11]-n[7]*n[8]*n[14]+n[7]*n[12]*n[10],r[5]=n[0]*n[10]*n[15]-n[0]*n[14]*n[11]-n[2]*n[8]*n[15]+n[2]*n[12]*n[11]+n[3]*n[8]*n[14]-n[3]*n[12]*n[10],r[6]=-n[0]*n[6]*n[15]+n[0]*n[14]*n[7]+n[2]*n[4]*n[15]-n[2]*n[12]*n[7]-n[3]*n[4]*n[14]+n[3]*n[12]*n[6],r[7]=n[0]*n[6]*n[11]-n[0]*n[10]*n[7]-n[2]*n[4]*n[11]+n[2]*n[8]*n[7]+n[3]*n[4]*n[10]-n[3]*n[8]*n[6],r[8]=n[4]*n[9]*n[15]-n[4]*n[13]*n[11]-n[5]*n[8]*n[15]+n[5]*n[12]*n[11]+n[7]*n[8]*n[13]-n[7]*n[12]*n[9],r[9]=-n[0]*n[9]*n[15]+n[0]*n[13]*n[11]+n[1]*n[8]*n[15]-n[1]*n[12]*n[11]-n[3]*n[8]*n[13]+n[3]*n[12]*n[9],r[10]=n[0]*n[5]*n[15]-n[0]*n[13]*n[7]-n[1]*n[4]*n[15]+n[1]*n[12]*n[7]+n[3]*n[4]*n[13]-n[3]*n[12]*n[5],r[11]=-n[0]*n[5]*n[11]+n[0]*n[9]*n[7]+n[1]*n[4]*n[11]-n[1]*n[8]*n[7]-n[3]*n[4]*n[9]+n[3]*n[8]*n[5],r[12]=-n[4]*n[9]*n[14]+n[4]*n[13]*n[10]+n[5]*n[8]*n[14]-n[5]*n[12]*n[10]-n[6]*n[8]*n[13]+n[6]*n[12]*n[9],r[13]=n[0]*n[9]*n[14]-n[0]*n[13]*n[10]-n[1]*n[8]*n[14]+n[1]*n[12]*n[10]+n[2]*n[8]*n[13]-n[2]*n[12]*n[9],r[14]=-n[0]*n[5]*n[14]+n[0]*n[13]*n[6]+n[1]*n[4]*n[14]-n[1]*n[12]*n[6]-n[2]*n[4]*n[13]+n[2]*n[12]*n[5],r[15]=n[0]*n[5]*n[10]-n[0]*n[9]*n[6]-n[1]*n[4]*n[10]+n[1]*n[8]*n[6]+n[2]*n[4]*n[9]-n[2]*n[8]*n[5];for(var i=n[0]*r[0]+n[1]*r[4]+n[2]*r[8]+n[3]*r[12],o=0;o<16;o++)r[o]/=i;return t},s.transpose=function(e,t){t=t||new s;var n=e.m,r=t.m;return r[0]=n[0],r[1]=n[4],r[2]=n[8],r[3]=n[12],r[4]=n[1],r[5]=n[5],r[6]=n[9],r[7]=n[13],r[8]=n[2],r[9]=n[6],r[10]=n[10],r[11]=n[14],r[12]=n[3],r[13]=n[7],r[14]=n[11],r[15]=n[15],t},s.multiply=function(e,t,n){n=n||new s;var r=e.m,i=t.m,o=n.m;return o[0]=r[0]*i[0]+r[1]*i[4]+r[2]*i[8]+r[3]*i[12],o[1]=r[0]*i[1]+r[1]*i[5]+r[2]*i[9]+r[3]*i[13],o[2]=r[0]*i[2]+r[1]*i[6]+r[2]*i[10]+r[3]*i[14],o[3]=r[0]*i[3]+r[1]*i[7]+r[2]*i[11]+r[3]*i[15],o[4]=r[4]*i[0]+r[5]*i[4]+r[6]*i[8]+r[7]*i[12],o[5]=r[4]*i[1]+r[5]*i[5]+r[6]*i[9]+r[7]*i[13],o[6]=r[4]*i[2]+r[5]*i[6]+r[6]*i[10]+r[7]*i[14],o[7]=r[4]*i[3]+r[5]*i[7]+r[6]*i[11]+r[7]*i[15],o[8]=r[8]*i[0]+r[9]*i[4]+r[10]*i[8]+r[11]*i[12],o[9]=r[8]*i[1]+r[9]*i[5]+r[10]*i[9]+r[11]*i[13],o[10]=r[8]*i[2]+r[9]*i[6]+r[10]*i[10]+r[11]*i[14],o[11]=r[8]*i[3]+r[9]*i[7]+r[10]*i[11]+r[11]*i[15],o[12]=r[12]*i[0]+r[13]*i[4]+r[14]*i[8]+r[15]*i[12],o[13]=r[12]*i[1]+r[13]*i[5]+r[14]*i[9]+r[15]*i[13],o[14]=r[12]*i[2]+r[13]*i[6]+r[14]*i[10]+r[15]*i[14],o[15]=r[12]*i[3]+r[13]*i[7]+r[14]*i[11]+r[15]*i[15],n},s.identity=function(e){var t=(e=e||new s).m;return t[0]=t[5]=t[10]=t[15]=1,t[1]=t[2]=t[3]=t[4]=t[6]=t[7]=t[8]=t[9]=t[11]=t[12]=t[13]=t[14]=0,e},s.perspective=function(e,t,n,r,i){var o=Math.tan(e*Math.PI/360)*n,a=o*t;return s.frustum(-a,a,-o,o,n,r,i)},s.frustum=function(e,t,n,r,i,o,a){var c=(a=a||new s).m;return c[0]=2*i/(t-e),c[1]=0,c[2]=(t+e)/(t-e),c[3]=0,c[4]=0,c[5]=2*i/(r-n),c[6]=(r+n)/(r-n),c[7]=0,c[8]=0,c[9]=0,c[10]=-(o+i)/(o-i),c[11]=-2*o*i/(o-i),c[12]=0,c[13]=0,c[14]=-1,c[15]=0,a},s.ortho=function(e,t,n,r,i,o,a){var c=(a=a||new s).m;return c[0]=2/(t-e),c[1]=0,c[2]=0,c[3]=-(t+e)/(t-e),c[4]=0,c[5]=2/(r-n),c[6]=0,c[7]=-(r+n)/(r-n),c[8]=0,c[9]=0,c[10]=-2/(o-i),c[11]=-(o+i)/(o-i),c[12]=0,c[13]=0,c[14]=0,c[15]=1,a},s.scale=function(e,t,n,r){var i=(r=r||new s).m;return i[0]=e,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=t,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=n,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,r},s.translate=function(e,t,n,r){var i=(r=r||new s).m;return i[0]=1,i[1]=0,i[2]=0,i[3]=e,i[4]=0,i[5]=1,i[6]=0,i[7]=t,i[8]=0,i[9]=0,i[10]=1,i[11]=n,i[12]=0,i[13]=0,i[14]=0,i[15]=1,r},s.rotate=function(e,t,n,r,i){if(!e||!t&&!n&&!r)return s.identity(i);var o=(i=i||new s).m,a=Math.sqrt(t*t+n*n+r*r);e*=Math.PI/180,t/=a,n/=a,r/=a;var c=Math.cos(e),u=Math.sin(e),l=1-c;return o[0]=t*t*l+c,o[1]=t*n*l-r*u,o[2]=t*r*l+n*u,o[3]=0,o[4]=n*t*l+r*u,o[5]=n*n*l+c,o[6]=n*r*l-t*u,o[7]=0,o[8]=r*t*l-n*u,o[9]=r*n*l+t*u,o[10]=r*r*l+c,o[11]=0,o[12]=0,o[13]=0,o[14]=0,o[15]=1,i},s.lookAt=function(e,t,n,r,i,o,a,c,u,l){var h=(l=l||new s).m,f=new E(e,t,n),d=new E(r,i,o),m=new E(a,c,u),v=f.subtract(d).unit(),p=m.cross(v).unit(),g=v.cross(p).unit();return h[0]=p.x,h[1]=p.y,h[2]=p.z,h[3]=-p.dot(f),h[4]=g.x,h[5]=g.y,h[6]=g.z,h[7]=-g.dot(f),h[8]=v.x,h[9]=v.y,h[10]=v.z,h[11]=-v.dot(f),h[12]=0,h[13]=0,h[14]=0,h[15]=1,l},c.prototype={add:function(e){var t=JSON.stringify(e);return t in this.map||(this.map[t]=this.unique.length,this.unique.push(e)),this.map[t]}},u.prototype={compile:function(t){for(var n=[],r=0;r<this.data.length;r+=1e4)n=Array.prototype.concat.apply(n,this.data.slice(r,r+1e4));var i=this.data.length?n.length/this.data.length:0;if(i!=Math.round(i))throw new Error("buffer elements not of consistent size, average size is "+i);this.buffer=this.buffer||e.createBuffer(),this.buffer.length=n.length,this.buffer.spacing=i,e.bindBuffer(this.target,this.buffer),e.bufferData(this.target,new this.type(n),t||e.STATIC_DRAW)}},l.prototype={addVertexBuffer:function(t,n){(this.vertexBuffers[n]=new u(e.ARRAY_BUFFER,Float32Array)).name=t,this[t]=[]},addIndexBuffer:function(t){this.indexBuffers[t]=new u(e.ELEMENT_ARRAY_BUFFER,Uint16Array);this[t]=[]},compile:function(){for(var e in this.vertexBuffers){(n=this.vertexBuffers[e]).data=this[n.name],n.compile()}for(var t in this.indexBuffers){var n;(n=this.indexBuffers[t]).data=this[t],n.compile()}},transform:function(e){if(this.vertices=this.vertices.map((function(t){return e.transformPoint(E.fromArray(t)).toArray()})),this.normals){var t=e.inverse().transpose();this.normals=this.normals.map((function(e){return t.transformVector(E.fromArray(e)).unit().toArray()}))}return this.compile(),this},computeNormals:function(){this.normals||this.addVertexBuffer("normals","gl_Normal");for(var e=0;e<this.vertices.length;e++)this.normals[e]=new E;for(e=0;e<this.triangles.length;e++){var t=this.triangles[e],n=E.fromArray(this.vertices[t[0]]),r=E.fromArray(this.vertices[t[1]]),i=E.fromArray(this.vertices[t[2]]),o=r.subtract(n).cross(i.subtract(n)).unit();this.normals[t[0]]=this.normals[t[0]].add(o),this.normals[t[1]]=this.normals[t[1]].add(o),this.normals[t[2]]=this.normals[t[2]].add(o)}for(e=0;e<this.vertices.length;e++)this.normals[e]=this.normals[e].unit().toArray();return this.compile(),this},computeWireframe:function(){for(var e=new c,t=0;t<this.triangles.length;t++)for(var n=this.triangles[t],r=0;r<n.length;r++){var i=n[r],o=n[(r+1)%n.length];e.add([Math.min(i,o),Math.max(i,o)])}return this.lines||this.addIndexBuffer("lines"),this.lines=e.unique,this.compile(),this},getAABB:function(){var e={min:new E(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)};e.max=e.min.negative();for(var t=0;t<this.vertices.length;t++){var n=E.fromArray(this.vertices[t]);e.min=E.min(e.min,n),e.max=E.max(e.max,n)}return e},getBoundingSphere:function(){for(var e=this.getAABB(),t={center:e.min.add(e.max).divide(2),radius:0},n=0;n<this.vertices.length;n++)t.radius=Math.max(t.radius,E.fromArray(this.vertices[n]).subtract(t.center).length());return t}},l.plane=function(e){for(var t=new l(e=e||{}),n=e.detailX||e.detail||1,r=e.detailY||e.detail||1,i=0;i<=r;i++)for(var o=i/r,a=0;a<=n;a++){var s=a/n;if(t.vertices.push([2*s-1,2*o-1,0]),t.coords&&t.coords.push([s,o]),t.normals&&t.normals.push([0,0,1]),a<n&&i<r){var c=a+i*(n+1);t.triangles.push([c,c+1,c+n+1]),t.triangles.push([c+n+1,c+1,c+n+2])}}return t.compile(),t};var h=[[0,4,2,6,-1,0,0],[1,3,5,7,1,0,0],[0,1,4,5,0,-1,0],[2,6,3,7,0,1,0],[0,2,1,3,0,0,-1],[4,5,6,7,0,0,1]];function f(e){return new E(2*(1&e)-1,(2&e)-1,(4&e)/2-1)}function d(e,t,n){this.t=arguments.length?e:Number.MAX_VALUE,this.hit=t,this.normal=n}function m(){var t=e.getParameter(e.VIEWPORT),n=e.modelviewMatrix.m,r=new E(n[0],n[4],n[8]),i=new E(n[1],n[5],n[9]),o=new E(n[2],n[6],n[10]),a=new E(n[3],n[7],n[11]);this.eye=new E(-a.dot(r),-a.dot(i),-a.dot(o));var s=t[0],c=s+t[2],u=t[1],l=u+t[3];this.ray00=e.unProject(s,u,1).subtract(this.eye),this.ray10=e.unProject(c,u,1).subtract(this.eye),this.ray01=e.unProject(s,l,1).subtract(this.eye),this.ray11=e.unProject(c,l,1).subtract(this.eye),this.viewport=t}function v(e,t,n){for(var r;null!=(r=e.exec(t));)n(r)}l.cube=function(e){for(var t=new l(e),n=0;n<h.length;n++){for(var r=h[n],i=4*n,o=0;o<4;o++){var a=r[o];t.vertices.push(f(a).toArray()),t.coords&&t.coords.push([1&o,(2&o)/2]),t.normals&&t.normals.push(r.slice(4,7))}t.triangles.push([i,i+1,i+2]),t.triangles.push([i+2,i+1,i+3])}return t.compile(),t},l.sphere=function(e){function t(e,t,n){return u?[e,n,t]:[e,t,n]}function n(e){return e+(e-e*e)/2}for(var r=new l(e=e||{}),i=new c,o=e.detail||6,a=0;a<8;a++)for(var s=f(a),u=s.x*s.y*s.z>0,h=[],d=0;d<=o;d++){for(var m=0;d+m<=o;m++){var v=m/o,p=(o-d-m)/o,g={vertex:new E(n(y=d/o),n(v),n(p)).unit().multiply(s).toArray()};r.coords&&(g.coord=s.y>0?[1-y,p]:[p,1-y]),h.push(i.add(g))}if(d>0)for(m=0;d+m<=o;m++){var y=(d-1)*(o+1)+(d-1-(d-1)*(d-1))/2+m;v=d*(o+1)+(d-d*d)/2+m;r.triangles.push(t(h[y],h[y+1],h[v])),d+m<o&&r.triangles.push(t(h[v],h[y+1],h[v+1]))}}return r.vertices=i.unique.map((function(e){return e.vertex})),r.coords&&(r.coords=i.unique.map((function(e){return e.coord}))),r.normals&&(r.normals=r.vertices),r.compile(),r},l.load=function(e,t){"coords"in(t=t||{})||(t.coords=!!e.coords),"normals"in t||(t.normals=!!e.normals),"colors"in t||(t.colors=!!e.colors),"triangles"in t||(t.triangles=!!e.triangles),"lines"in t||(t.lines=!!e.lines);var n=new l(t);return n.vertices=e.vertices,n.coords&&(n.coords=e.coords),n.normals&&(n.normals=e.normals),n.colors&&(n.colors=e.colors),n.triangles&&(n.triangles=e.triangles),n.lines&&(n.lines=e.lines),n.compile(),n},d.prototype={mergeWith:function(e){e.t>0&&e.t<this.t&&(this.t=e.t,this.hit=e.hit,this.normal=e.normal)}},m.prototype={getRayForPixel:function(e,t){e=(e-this.viewport[0])/this.viewport[2],t=1-(t-this.viewport[1])/this.viewport[3];var n=E.lerp(this.ray00,this.ray10,e),r=E.lerp(this.ray01,this.ray11,e);return E.lerp(n,r,t).unit()}},m.hitTestBox=function(e,t,n,r){var i=n.subtract(e).divide(t),o=r.subtract(e).divide(t),a=E.min(i,o),s=E.max(i,o),c=a.max(),u=s.min();if(c>0&&c<u){var l=e.add(t.multiply(c));return n=n.add(1e-6),r=r.subtract(1e-6),new d(c,l,new E((l.x>r.x)-(l.x<n.x),(l.y>r.y)-(l.y<n.y),(l.z>r.z)-(l.z<n.z)))}return null},m.hitTestSphere=function(e,t,n,r){var i=e.subtract(n),o=t.dot(t),a=2*t.dot(i),s=a*a-4*o*(i.dot(i)-r*r);if(s>0){var c=(-a-Math.sqrt(s))/(2*o),u=e.add(t.multiply(c));return new d(c,u,u.subtract(n).divide(r))}return null},m.hitTestTriangle=function(e,t,n,r,i){var o=r.subtract(n),a=i.subtract(n),s=o.cross(a).unit(),c=s.dot(n.subtract(e))/s.dot(t);if(c>0){var u=e.add(t.multiply(c)),l=u.subtract(n),h=a.dot(a),f=a.dot(o),m=a.dot(l),v=o.dot(o),p=o.dot(l),g=h*v-f*f,y=(v*m-f*p)/g,x=(h*p-f*m)/g;if(y>=0&&x>=0&&y+x<=1)return new d(c,u,s)}return null};var p="LIGHTGL";function g(t,n){function r(e){var t=document.getElementById(e);return t?t.text:e}var i="    uniform mat3 gl_NormalMatrix;    uniform mat4 gl_ModelViewMatrix;    uniform mat4 gl_ProjectionMatrix;    uniform mat4 gl_ModelViewProjectionMatrix;    uniform mat4 gl_ModelViewMatrixInverse;    uniform mat4 gl_ProjectionMatrixInverse;    uniform mat4 gl_ModelViewProjectionMatrixInverse;  ",o=(t=r(t))+(n=r(n)),a={};function s(e,t){var n={},r=/^((\s*\/\/.*\n|\s*#extension.*\n)+)[^]*$/.exec(t);return t=r?r[1]+e+t.substr(r[1].length):e+t,v(/\bgl_\w+\b/g,e,(function(e){e in n||(t=t.replace(new RegExp("\\b"+e+"\\b","g"),p+e),n[e]=!0)})),t}function c(t,n){var r=e.createShader(t);if(e.shaderSource(r,n),e.compileShader(r),!e.getShaderParameter(r,e.COMPILE_STATUS))throw new Error("compile error: "+e.getShaderInfoLog(r));return r}if(v(/\b(gl_[^;]*)\b;/g,i,(function(e){var t=e[1];if(-1!=o.indexOf(t)){var n=t.replace(/[a-z_]/g,"");a[n]=p+t}})),-1!=o.indexOf("ftransform")&&(a.MVPM=p+"gl_ModelViewProjectionMatrix"),this.usedMatrices=a,t=s("    uniform mat3 gl_NormalMatrix;    uniform mat4 gl_ModelViewMatrix;    uniform mat4 gl_ProjectionMatrix;    uniform mat4 gl_ModelViewProjectionMatrix;    uniform mat4 gl_ModelViewMatrixInverse;    uniform mat4 gl_ProjectionMatrixInverse;    uniform mat4 gl_ModelViewProjectionMatrixInverse;      attribute vec4 gl_Vertex;    attribute vec4 gl_TexCoord;    attribute vec3 gl_Normal;    attribute vec4 gl_Color;    vec4 ftransform() {      return gl_ModelViewProjectionMatrix * gl_Vertex;    }  ",t),n=s("    precision highp float;      uniform mat3 gl_NormalMatrix;    uniform mat4 gl_ModelViewMatrix;    uniform mat4 gl_ProjectionMatrix;    uniform mat4 gl_ModelViewProjectionMatrix;    uniform mat4 gl_ModelViewMatrixInverse;    uniform mat4 gl_ProjectionMatrixInverse;    uniform mat4 gl_ModelViewProjectionMatrixInverse;  ",n),this.program=e.createProgram(),e.attachShader(this.program,c(e.VERTEX_SHADER,t)),e.attachShader(this.program,c(e.FRAGMENT_SHADER,n)),e.linkProgram(this.program),!e.getProgramParameter(this.program,e.LINK_STATUS))throw new Error("link error: "+e.getProgramInfoLog(this.program));this.attributes={},this.uniformLocations={};var u={};v(/uniform\s+sampler(1D|2D|3D|Cube)\s+(\w+)\s*;/g,t+n,(function(e){u[e[2]]=1})),this.isSampler=u}function y(e){var t=Object.prototype.toString.call(e);return"[object Number]"==t||"[object Boolean]"==t}var x,w,b;new s,new s;function R(t,n,r){r=r||{},this.id=e.createTexture(),this.width=t,this.height=n,this.format=r.format||e.RGBA,this.type=r.type||e.UNSIGNED_BYTE;var i=r.filter||r.magFilter||e.LINEAR,o=r.filter||r.minFilter||e.LINEAR;if(this.type===e.FLOAT){if(!R.canUseFloatingPointTextures())throw new Error("OES_texture_float is required but not supported");if((o!==e.NEAREST||i!==e.NEAREST)&&!R.canUseFloatingPointLinearFiltering())throw new Error("OES_texture_float_linear is required but not supported")}else if(this.type===e.HALF_FLOAT_OES){if(!R.canUseHalfFloatingPointTextures())throw new Error("OES_texture_half_float is required but not supported");if((o!==e.NEAREST||i!==e.NEAREST)&&!R.canUseHalfFloatingPointLinearFiltering())throw new Error("OES_texture_half_float_linear is required but not supported")}e.bindTexture(e.TEXTURE_2D,this.id),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,1),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,i),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,o),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,r.wrap||r.wrapS||e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,r.wrap||r.wrapT||e.CLAMP_TO_EDGE),e.texImage2D(e.TEXTURE_2D,0,this.format,t,n,0,this.format,this.type,null)}function E(e,t,n){this.x=e||0,this.y=t||0,this.z=n||0}return g.prototype={uniforms:function(t){for(var n in e.useProgram(this.program),t){var r=this.uniformLocations[n]||e.getUniformLocation(this.program,n);if(r){this.uniformLocations[n]=r;var i=t[n];if(i instanceof E?i=[i.x,i.y,i.z]:i instanceof s&&(i=i.m),o=i,a=void 0,"[object Array]"==(a=Object.prototype.toString.call(o))||"[object Float32Array]"==a)switch(i.length){case 1:e.uniform1fv(r,new Float32Array(i));break;case 2:e.uniform2fv(r,new Float32Array(i));break;case 3:e.uniform3fv(r,new Float32Array(i));break;case 4:e.uniform4fv(r,new Float32Array(i));break;case 9:e.uniformMatrix3fv(r,!1,new Float32Array([i[0],i[3],i[6],i[1],i[4],i[7],i[2],i[5],i[8]]));break;case 16:e.uniformMatrix4fv(r,!1,new Float32Array([i[0],i[4],i[8],i[12],i[1],i[5],i[9],i[13],i[2],i[6],i[10],i[14],i[3],i[7],i[11],i[15]]));break;default:throw new Error("don't know how to load uniform \""+n+'" of length '+i.length)}else{if(!y(i))throw new Error('attempted to set uniform "'+n+'" to invalid value '+i);(this.isSampler[n]?e.uniform1i:e.uniform1f).call(e,r,i)}}}var o,a;return this},draw:function(t,n){this.drawBuffers(t.vertexBuffers,t.indexBuffers[n==e.LINES?"lines":"triangles"],arguments.length<2?e.TRIANGLES:n)},drawBuffers:function(t,n,r){var i=this.usedMatrices,o=e.modelviewMatrix,a=e.projectionMatrix,s=i.MVMI||i.NM?o.inverse():null,c=i.PMI?a.inverse():null,u=i.MVPM||i.MVPMI?a.multiply(o):null,l={};if(i.MVM&&(l[i.MVM]=o),i.MVMI&&(l[i.MVMI]=s),i.PM&&(l[i.PM]=a),i.PMI&&(l[i.PMI]=c),i.MVPM&&(l[i.MVPM]=u),i.MVPMI&&(l[i.MVPMI]=u.inverse()),i.NM){var h=s.m;l[i.NM]=[h[0],h[4],h[8],h[1],h[5],h[9],h[2],h[6],h[10]]}this.uniforms(l);var f=0;for(var d in t){var m=t[d],v=this.attributes[d]||e.getAttribLocation(this.program,d.replace(/^(gl_.*)$/,p+"$1"));-1!=v&&m.buffer&&(this.attributes[d]=v,e.bindBuffer(e.ARRAY_BUFFER,m.buffer),e.enableVertexAttribArray(v),e.vertexAttribPointer(v,m.buffer.spacing,e.FLOAT,!1,0,0),f=m.buffer.length/m.buffer.spacing)}for(var d in this.attributes)d in t||e.disableVertexAttribArray(this.attributes[d]);return!f||n&&!n.buffer||(n?(e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n.buffer),e.drawElements(r,n.buffer.length,e.UNSIGNED_SHORT,0)):e.drawArrays(r,0,f)),this}},R.prototype={bind:function(t){e.activeTexture(e.TEXTURE0+(t||0)),e.bindTexture(e.TEXTURE_2D,this.id)},unbind:function(t){e.activeTexture(e.TEXTURE0+(t||0)),e.bindTexture(e.TEXTURE_2D,null)},canDrawTo:function(){x=x||e.createFramebuffer(),e.bindFramebuffer(e.FRAMEBUFFER,x),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.id,0);var t=e.checkFramebufferStatus(e.FRAMEBUFFER)==e.FRAMEBUFFER_COMPLETE;return e.bindFramebuffer(e.FRAMEBUFFER,null),t},drawTo:function(t){var n=e.getParameter(e.VIEWPORT);if(x=x||e.createFramebuffer(),w=w||e.createRenderbuffer(),e.bindFramebuffer(e.FRAMEBUFFER,x),e.bindRenderbuffer(e.RENDERBUFFER,w),this.width==w.width&&this.height==w.height||(w.width=this.width,w.height=this.height,e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_COMPONENT16,this.width,this.height)),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.id,0),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,w),e.checkFramebufferStatus(e.FRAMEBUFFER)!=e.FRAMEBUFFER_COMPLETE)throw new Error("Rendering to this texture is not supported (incomplete framebuffer)");e.viewport(0,0,this.width,this.height),t(),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindRenderbuffer(e.RENDERBUFFER,null),e.viewport(n[0],n[1],n[2],n[3])},swapWith:function(e){var t;t=e.id,e.id=this.id,this.id=t,t=e.width,e.width=this.width,this.width=t,t=e.height,e.height=this.height,this.height=t}},R.fromImage=function(t,n){n=n||{};var r=new R(t.width,t.height,n);try{e.texImage2D(e.TEXTURE_2D,0,r.format,r.format,r.type,t)}catch(e){throw"file:"==location.protocol?new Error('image not loaded for security reasons (serve this page over "http://" instead)'):new Error("image not loaded for security reasons (image must originate from the same domain as this page or use Cross-Origin Resource Sharing)")}return n.minFilter&&n.minFilter!=e.NEAREST&&n.minFilter!=e.LINEAR&&e.generateMipmap(e.TEXTURE_2D),r},R.fromURL=function(t,n){b=b||function(){var e=document.createElement("canvas").getContext("2d");e.canvas.width=e.canvas.height=128;for(var t=0;t<e.canvas.height;t+=16)for(var n=0;n<e.canvas.width;n+=16)e.fillStyle=16&(n^t)?"#FFF":"#DDD",e.fillRect(n,t,16,16);return e.canvas}();var r=R.fromImage(b,n),i=new Image,o=e;return i.onload=function(){o.makeCurrent(),R.fromImage(i,n).swapWith(r)},i.src=t,r},R.canUseFloatingPointTextures=function(){return!!e.getExtension("OES_texture_float")},R.canUseFloatingPointLinearFiltering=function(){return!!e.getExtension("OES_texture_float_linear")},R.canUseHalfFloatingPointTextures=function(){return!!e.getExtension("OES_texture_half_float")},R.canUseHalfFloatingPointLinearFiltering=function(){return!!e.getExtension("OES_texture_half_float_linear")},E.prototype={negative:function(){return new E(-this.x,-this.y,-this.z)},add:function(e){return e instanceof E?new E(this.x+e.x,this.y+e.y,this.z+e.z):new E(this.x+e,this.y+e,this.z+e)},subtract:function(e){return e instanceof E?new E(this.x-e.x,this.y-e.y,this.z-e.z):new E(this.x-e,this.y-e,this.z-e)},multiply:function(e){return e instanceof E?new E(this.x*e.x,this.y*e.y,this.z*e.z):new E(this.x*e,this.y*e,this.z*e)},divide:function(e){return e instanceof E?new E(this.x/e.x,this.y/e.y,this.z/e.z):new E(this.x/e,this.y/e,this.z/e)},equals:function(e){return this.x==e.x&&this.y==e.y&&this.z==e.z},dot:function(e){return this.x*e.x+this.y*e.y+this.z*e.z},cross:function(e){return new E(this.y*e.z-this.z*e.y,this.z*e.x-this.x*e.z,this.x*e.y-this.y*e.x)},length:function(){return Math.sqrt(this.dot(this))},unit:function(){return this.divide(this.length())},min:function(){return Math.min(Math.min(this.x,this.y),this.z)},max:function(){return Math.max(Math.max(this.x,this.y),this.z)},toAngles:function(){return{theta:Math.atan2(this.z,this.x),phi:Math.asin(this.y/this.length())}},angleTo:function(e){return Math.acos(this.dot(e)/(this.length()*e.length()))},toArray:function(e){return[this.x,this.y,this.z].slice(0,e||3)},clone:function(){return new E(this.x,this.y,this.z)},init:function(e,t,n){return this.x=e,this.y=t,this.z=n,this}},E.negative=function(e,t){return t.x=-e.x,t.y=-e.y,t.z=-e.z,t},E.add=function(e,t,n){return t instanceof E?(n.x=e.x+t.x,n.y=e.y+t.y,n.z=e.z+t.z):(n.x=e.x+t,n.y=e.y+t,n.z=e.z+t),n},E.subtract=function(e,t,n){return t instanceof E?(n.x=e.x-t.x,n.y=e.y-t.y,n.z=e.z-t.z):(n.x=e.x-t,n.y=e.y-t,n.z=e.z-t),n},E.multiply=function(e,t,n){return t instanceof E?(n.x=e.x*t.x,n.y=e.y*t.y,n.z=e.z*t.z):(n.x=e.x*t,n.y=e.y*t,n.z=e.z*t),n},E.divide=function(e,t,n){return t instanceof E?(n.x=e.x/t.x,n.y=e.y/t.y,n.z=e.z/t.z):(n.x=e.x/t,n.y=e.y/t,n.z=e.z/t),n},E.cross=function(e,t,n){return n.x=e.y*t.z-e.z*t.y,n.y=e.z*t.x-e.x*t.z,n.z=e.x*t.y-e.y*t.x,n},E.unit=function(e,t){var n=e.length();return t.x=e.x/n,t.y=e.y/n,t.z=e.z/n,t},E.fromAngles=function(e,t){return new E(Math.cos(e)*Math.cos(t),Math.sin(t),Math.sin(e)*Math.cos(t))},E.randomDirection=function(){return E.fromAngles(Math.random()*Math.PI*2,Math.asin(2*Math.random()-1))},E.min=function(e,t){return new E(Math.min(e.x,t.x),Math.min(e.y,t.y),Math.min(e.z,t.z))},E.max=function(e,t){return new E(Math.max(e.x,t.x),Math.max(e.y,t.y),Math.max(e.z,t.z))},E.lerp=function(e,t,n){return t.subtract(e).multiply(n).add(e)},E.fromArray=function(e){return new E(e[0],e[1],e[2])},E.angleBetween=function(e,t){return e.angleTo(t)},t}();const i=3.141592653589793,o=new r.Vector(0,-9.8,0);function a(e,t,n){this.oldCenter=this.center=e,this.radius=t,this.velocity=n}a.prototype.updateCenter=function(e){this.oldCenter=this.center,this.center=e},a.prototype.updateVelocity=function(e){this.velocity=e},a.prototype.simulate=function(e){var t=Math.max(0,Math.min(1,(this.radius-this.center.y)/(2*this.radius)));this.velocity=this.velocity.add(o.multiply(e-1/.89*e*t)),this.velocity=this.velocity.subtract(this.velocity.unit().multiply(t*e*this.velocity.dot(this.velocity))),this.center=this.center.add(this.velocity.multiply(e)),this.radius=(1+.005*e)*this.radius,this.center.y<this.radius-1&&(this.center.y=this.radius-1,this.velocity.y=.75*Math.abs(this.velocity.y))},a.prototype.getVolume=function(){return 4*i*Math.pow(this.radius,3)/3};var s=a;function c(e){this.id=re.createTexture(),re.bindTexture(re.TEXTURE_CUBE_MAP,this.id),re.pixelStorei(re.UNPACK_FLIP_Y_WEBGL,1),re.texParameteri(re.TEXTURE_CUBE_MAP,re.TEXTURE_MAG_FILTER,re.LINEAR),re.texParameteri(re.TEXTURE_CUBE_MAP,re.TEXTURE_MIN_FILTER,re.LINEAR),re.texParameteri(re.TEXTURE_CUBE_MAP,re.TEXTURE_WRAP_S,re.CLAMP_TO_EDGE),re.texParameteri(re.TEXTURE_CUBE_MAP,re.TEXTURE_WRAP_T,re.CLAMP_TO_EDGE),re.texImage2D(re.TEXTURE_CUBE_MAP_NEGATIVE_X,0,re.RGB,re.RGB,re.UNSIGNED_BYTE,e.xneg),re.texImage2D(re.TEXTURE_CUBE_MAP_POSITIVE_X,0,re.RGB,re.RGB,re.UNSIGNED_BYTE,e.xpos),re.texImage2D(re.TEXTURE_CUBE_MAP_NEGATIVE_Y,0,re.RGB,re.RGB,re.UNSIGNED_BYTE,e.yneg),re.texImage2D(re.TEXTURE_CUBE_MAP_POSITIVE_Y,0,re.RGB,re.RGB,re.UNSIGNED_BYTE,e.ypos),re.texImage2D(re.TEXTURE_CUBE_MAP_NEGATIVE_Z,0,re.RGB,re.RGB,re.UNSIGNED_BYTE,e.zneg),re.texImage2D(re.TEXTURE_CUBE_MAP_POSITIVE_Z,0,re.RGB,re.RGB,re.UNSIGNED_BYTE,e.zpos)}c.prototype.bind=function(e){re.activeTexture(re.TEXTURE0+(e||0)),re.bindTexture(re.TEXTURE_CUBE_MAP,this.id)},c.prototype.unbind=function(e){re.activeTexture(re.TEXTURE0+(e||0)),re.bindTexture(re.TEXTURE_CUBE_MAP,null)};var u=c,l=n(1),h=n.n(l),f=n(2),d=n.n(f),m=n(3),v=n.n(m),p=n(4),g=n.n(p),y=n(5),x=n.n(y),w=n(6),b=n.n(w),R=n(7),E=n.n(R),M=n(8),_=n.n(M),C=n(9),T=n.n(C),A=n(10),I=n.n(A);function F(){this.tileTexture=r.Texture.fromImage(document.getElementById("tiles"),{minFilter:re.LINEAR_MIPMAP_LINEAR,wrap:re.REPEAT,format:re.RGB}),this.lightDir=new r.Vector(2,2,-1).unit(),this.waterMesh=r.Mesh.plane({detail:200}),this.waterShaders=[];for(var e=0;e<2;e++)this.waterShaders[e]=new r.Shader(T.a,I.a);this.sphereMesh=r.Mesh.sphere({detail:10}),this.sphereShader=new r.Shader(E.a,_.a),this.bubbleMesh=r.Mesh.sphere({detail:10}),this.bubbleShader=new r.Shader(h.a,d.a),this.cubeMesh=r.Mesh.cube(),this.cubeMesh.triangles.splice(4,2),this.cubeMesh.compile(),this.cubeShader=new r.Shader(x.a,b.a),this.causticTex=new r.Texture(1024,1024);re.getExtension("OES_standard_derivatives");this.causticsShader=new r.Shader(v.a,g.a)}F.prototype.updateCaustics=function(e,t){if(this.causticsShader){var n=!!re.getExtension("OES_standard_derivatives"),r=this;this.causticTex.drawTo((function(){re.clear(re.COLOR_BUFFER_BIT),e.textureA.bind(0),r.causticsShader.uniforms({light:r.lightDir,water:0,sphereCenter:t.center,sphereRadius:t.radius,hasDerivatives:n}).draw(r.waterMesh)}))}},F.prototype.renderWater=function(e,t,n){var i=new r.Raytracer;e.textureA.bind(0),this.tileTexture.bind(1),t.bind(2),this.causticTex.bind(3),re.enable(re.CULL_FACE);for(var o=0;o<2;o++)re.cullFace(o?re.BACK:re.FRONT),this.waterShaders[o].uniforms({light:this.lightDir,water:0,tiles:1,sky:2,causticTex:3,eye:i.eye,isUnderWater:o,sphereCenter:n.center,sphereRadius:n.radius}).draw(this.waterMesh);re.disable(re.CULL_FACE)},F.prototype.renderBubble=function(e,t){var n=new r.Raytracer;J.textureA.bind(0),this.tileTexture.bind(1),e.bind(2),this.causticTex.bind(3),re.enable(re.CULL_FACE),this.bubbleShader.uniforms({light:this.lightDir,water:0,tiles:1,sky:2,causticTex:3,eye:n.eye,sphereCenter:t.center,sphereRadius:t.radius}).draw(this.sphereMesh)},F.prototype.renderSphere=function(e){J.textureA.bind(0),this.causticTex.bind(1),this.sphereShader.uniforms({light:this.lightDir,water:0,causticTex:1,sphereCenter:e.center,sphereRadius:e.radius}).draw(this.sphereMesh)},F.prototype.renderCube=function(e){re.enable(re.CULL_FACE),J.textureA.bind(0),this.tileTexture.bind(1),this.causticTex.bind(2),this.cubeShader.uniforms({light:this.lightDir,water:0,tiles:1,causticTex:2,sphereCenter:e.center,sphereRadius:e.radius}).draw(this.cubeMesh),re.disable(re.CULL_FACE)};var P=F;function S(e,t,n){this.oldCenter=this.center=e,this.radius=t,this.velocity=n}S.prototype.updateCenter=function(e){this.oldCenter=this.center,this.center=e},S.prototype.updateVelocity=function(e){this.velocity=e},S.prototype.simulate=function(e){var t=Math.max(0,Math.min(1,(this.radius-this.center.y)/(2*this.radius)));this.velocity=this.velocity.add(o.multiply(e-1/.93*e*t)),this.velocity=this.velocity.subtract(this.velocity.unit().multiply(t*e*this.velocity.dot(this.velocity))),this.center=this.center.add(this.velocity.multiply(e)),this.center.y<this.radius-1&&(this.center.y=this.radius-1,this.velocity.y=.75*Math.abs(this.velocity.y))},S.prototype.getVolume=function(){return 4*i*this.radius*this.radius*this.radius/3};var z=S,D=n(11),B=n.n(D),L=n(12),O=n.n(L),U=n(13),N=n.n(U),V=n(14),W=n.n(V),X=n(15),j=n.n(X),H=n(16),k=n.n(H),G=n(0),Y=n.n(G);function q(){if(this.plane=r.Mesh.plane(),!r.Texture.canUseFloatingPointTextures())throw new Error("This demo requires the OES_texture_float extension");var e=r.Texture.canUseFloatingPointLinearFiltering()?re.LINEAR:re.NEAREST;this.textureA=new r.Texture(256,256,{type:re.FLOAT,filter:e}),this.textureB=new r.Texture(256,256,{type:re.FLOAT,filter:e}),this.textureA.canDrawTo()&&this.textureB.canDrawTo()||!r.Texture.canUseHalfFloatingPointTextures()||(e=r.Texture.canUseHalfFloatingPointLinearFiltering()?re.LINEAR:re.NEAREST,this.textureA=new r.Texture(256,256,{type:re.HALF_FLOAT_OES,filter:e}),this.textureB=new r.Texture(256,256,{type:re.HALF_FLOAT_OES,filter:e})),this.dropShader=new r.Shader(Y.a,B.a),this.updateShader=new r.Shader(Y.a,k.a),this.normalShader=new r.Shader(Y.a,O.a),this.sphereShader=new r.Shader(Y.a,W.a),this.bubbleShader=new r.Shader(Y.a,N.a),this.removeBubbleShader=new r.Shader(Y.a,j.a)}q.prototype.addDrop=function(e,t,n,r){var i=this;this.textureB.drawTo((function(){i.textureA.bind(),i.dropShader.uniforms({center:[e,t],radius:n,strength:r}).draw(i.plane)})),this.textureB.swapWith(this.textureA)},q.prototype.removeBubble=function(e){var t=this;this.textureB.drawTo((function(){t.textureA.bind(),t.removeBubbleShader.uniforms({oldCenter:e.oldCenter,newCenter:e.center,radius:e.radius}).draw(t.plane)})),this.textureB.swapWith(this.textureA)},q.prototype.moveSingleBubble=function(e,t){var n=this;this.textureB.drawTo((function(){n.textureA.bind(),n.bubbleShader.uniforms({oldCenter:e.oldCenter,newCenter:e.center,radius:e.radius}).draw(n.plane)})),this.textureB.swapWith(this.textureA);var r=e.center,i=e.radius;return(r.subtract(t.center).length<i+t.radius||r.y+i>.01*i||r.x-i<-1||r.z-i<-1||1-r.x<i||1-r.z<i)&&(this.removeBubble(e),!0)},q.prototype.moveSphere=function(e){var t=this;this.textureB.drawTo((function(){t.textureA.bind(),t.sphereShader.uniforms({oldCenter:e.oldCenter,newCenter:e.center,radius:e.radius}).draw(t.plane)})),this.textureB.swapWith(this.textureA)},q.prototype.stepSimulation=function(){var e=this;this.textureB.drawTo((function(){e.textureA.bind(),e.updateShader.uniforms({delta:[1/e.textureA.width,1/e.textureA.height]}).draw(e.plane)})),this.textureB.swapWith(this.textureA)},q.prototype.updateNormals=function(){var e=this;this.textureB.drawTo((function(){e.textureA.bind(),e.normalShader.uniforms({delta:[1/e.textureA.width,1/e.textureA.height]}).draw(e.plane)})),this.textureB.swapWith(this.textureA)};var K=q;n.d(t,"gl",(function(){return re})),n.d(t,"water",(function(){return J})),window.onerror=function(e){var t=function(e){return e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/\n/g,"<br>")}(e);"WebGL not supported"==t&&(t='Your browser does not support WebGL.<br>Please see    <a href="http://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">    Getting a WebGL Implementation</a>.');var n=document.getElementById("loading");n.innerHTML=t,n.style.zIndex=1};var J,$,Z,Q,ee,te,ne,re=r.create(),ie=-25,oe=-200.5,ae=!1,se=!1,ce=new VRFrameData;console.log("out of function"),window.onload=function(){navigator.getVRDisplays().then(e=>{0!==(e=e.filter(e=>e.capabilities.canPresent)).length?(ne=e[0]).requestPresent([{source:re.canvas}]).then((function(){console.log("request Present done."),function(){console.log("draw VR!");var e=window.devicePixelRatio||1,t=document.getElementById("help");function n(e){return new r.Matrix([e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15]]).transpose()}function i(){ne.getFrameData(ce),console.log("onresize");const i=()=>{console.log("animating");var o=(new Date).getTime();se||(!function(e){if(e>1)return;2*e,d==v?Q.updateVelocity(new r.Vector):ae&&(Q.simulate(e),ee.forEach((function(t){t.simulate(e)})),te=(te+1)%20);J.moveSphere(Q),Q.updateCenter(Q.center);var t=[];ee.forEach((function(e){var n=!J.moveSingleBubble(e,Q);e.updateCenter(e.center),n&&t.push(e)})),ee=t,J.stepSimulation(),J.updateNormals()}((o-l)/1e3),b()),l=o,ne.requestAnimationFrame(i);const a=ce.leftProjectionMatrix,s=ce.leftViewMatrix,c=ce.rightProjectionMatrix,u=ce.rightViewMatrix;var h=innerWidth-t.clientWidth-20,f=innerHeight;re.clear(re.COLOR_BUFFER_BIT|re.DEPTH_BUFFER_BIT);var m=n(a),p=n(s);re.canvas.width=h*e,re.canvas.height=f*e,re.canvas.style.width=h+"px",re.canvas.style.height=f+"px",re.viewport(0,0,.5*re.canvas.width,re.canvas.height),re.loadIdentity(),re.translate(0,0,-4),re.rotate(-ie,1,0,0),re.rotate(-oe,0,1,0),re.translate(0,.5,0),re.multMatrix(p),re.matrixMode(re.PROJECTION),re.loadIdentity(),re.multMatrix(m),re.matrixMode(re.MODELVIEW),b(!0);var g=n(c),y=n(u);re.viewport(.5*re.canvas.width,0,.5*re.canvas.width,re.canvas.height),re.loadIdentity(),re.translate(0,0,-4),re.rotate(-ie,1,0,0),re.rotate(-oe,0,1,0),re.translate(0,.5,0),re.multMatrix(y),re.matrixMode(re.PROJECTION),re.loadIdentity(),re.multMatrix(g),re.matrixMode(re.MODELVIEW),b(!1),ne.getFrameData(ce),ne.submitFrame()};i()}if(document.body.appendChild(re.canvas),re.clearColor(0,0,0,1),J=new K,Z=new P,$=new u({xneg:document.getElementById("xneg"),xpos:document.getElementById("xpos"),yneg:document.getElementById("ypos"),ypos:document.getElementById("ypos"),zneg:document.getElementById("zneg"),zpos:document.getElementById("zpos")}),!J.textureA.canDrawTo()||!J.textureB.canDrawTo())throw new Error("Rendering to floating-point textures is required but not supported");Q=new z(new r.Vector(-.4,-.75,.2),.25,new r.Vector),ee=[],te=0;for(var o=0;o<20;o++)J.addDrop(2*Math.random()-1,2*Math.random()-1,.03,1&o?.01:-.01);document.getElementById("loading").innerHTML="",i();window.requestAnimationFrame||window.webkitRequestAnimationFrame;var a,c,l=(new Date).getTime();window.onresize=i;var h,f,d=-1,m=0,v=1,p=2;function g(t,n){h=t,f=n;var i=new r.Raytracer,o=i.getRayForPixel(t*e,n*e),s=i.eye.add(o.multiply(-i.eye.y/o.y)),u=r.Raytracer.hitTestSphere(i.eye,o,Q.center,Q.radius);u?(d=v,a=u.hit,c=i.getRayForPixel(re.canvas.width/2,re.canvas.height/2).negative()):Math.abs(s.x)<1&&Math.abs(s.z)<1?(d=m,y(t,n)):d=p}function y(t,n){switch(d){case m:var i=(s=new r.Raytracer).getRayForPixel(t*e,n*e),o=s.eye.add(i.multiply(-s.eye.y/i.y));J.addDrop(o.x,o.z,.03,.01),se&&J.updateNormals();break;case v:i=(s=new r.Raytracer).getRayForPixel(t*e,n*e);var s,u=-c.dot(s.eye.subtract(a))/c.dot(i),l=s.eye.add(i.multiply(u)),g=Q.radius;Q.center=Q.center.add(l.subtract(a)),Q.center.x=Math.max(g-1,Math.min(1-g,Q.center.x)),Q.center.y=Math.max(g-1,Math.min(10,Q.center.y)),Q.center.z=Math.max(g-1,Math.min(1-g,Q.center.z)),a=l;break;case p:oe-=t-h,ie-=n-f,ie=Math.max(-89.999,Math.min(89.999,ie))}h=t,f=n,se&&b()}function x(){d=-1}function w(e){return e===t||e.parentNode&&w(e.parentNode)}document.onmousedown=function(e){w(e.target)||(e.preventDefault(),g(e.pageX,e.pageY))},document.onmousemove=function(e){y(e.pageX,e.pageY)},document.onmouseup=function(){x()},document.ontouchstart=function(e){1!==e.touches.length||w(e.target)||(e.preventDefault(),g(e.touches[0].pageX,e.touches[0].pageY))},document.ontouchmove=function(e){1===e.touches.length&&y(e.touches[0].pageX,e.touches[0].pageY)},document.ontouchend=function(e){0==e.touches.length&&x()},document.onkeydown=function(e){e.which==" ".charCodeAt(0)?se=!se:e.which=="G".charCodeAt(0)?ae=!ae:e.which=="L".charCodeAt(0)&&se?b():e.which=="B".charCodeAt(0)&&ee.push(new s(new r.Vector(1.8*Math.random()-.9,-1,1.8*Math.random()-.9),.1*Math.random(),new r.Vector(0,0,0)))};function b(e=!1){r.keys.L&&(Z.lightDir=r.Vector.fromAngles((90-oe)*Math.PI/180,-ie*Math.PI/180)),e&&re.clear(re.COLOR_BUFFER_BIT|re.DEPTH_BUFFER_BIT),re.enable(re.DEPTH_TEST),ee.forEach((function(e){Z.renderBubble($,e)})),Z.renderCube(Q),Z.renderWater(J,$,Q),Z.renderSphere(Q),re.disable(re.DEPTH_TEST)}}()})):console.warn("No devices available able to present.")})}}]);
//# sourceMappingURL=bundle.js.map